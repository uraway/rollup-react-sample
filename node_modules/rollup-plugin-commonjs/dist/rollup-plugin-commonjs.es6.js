import { statSync } from 'fs';
import { extname, basename, sep, dirname, resolve } from 'path';
import acorn from 'acorn';
import { walk } from 'estree-walker';
import MagicString from 'magic-string';
import { makeLegalIdentifier, attachScopes, createFilter } from 'rollup-pluginutils';

function isReference(node, parent) {
	if (parent.type === 'MemberExpression') return parent.computed || node === parent.object;

	// disregard the `bar` in { bar: foo }
	if (parent.type === 'Property' && node !== parent.value) return false;

	// disregard the `bar` in `class Foo { bar () {...} }`
	if (parent.type === 'MethodDefinition') return false;

	// disregard the `bar` in `export { foo as bar }`
	if (parent.type === 'ExportSpecifier' && node !== parent.local) return false;

	return true;
}

function flatten(node) {
	var name = undefined;
	var parts = [];

	while (node.type === 'MemberExpression') {
		if (node.computed) return null;

		parts.unshift(node.property.name);
		node = node.object;
	}

	if (node.type !== 'Identifier') return null;

	name = node.name;
	parts.unshift(name);

	return { name: name, keypath: parts.join('.') };
}

var firstpass = /\b(?:require|module|exports|global)\b/;
var exportsPattern = /^(?:module\.)?exports(?:\.([a-zA-Z_$][a-zA-Z_$0-9]*))?$/;

function getName(id) {
	var base = basename(id);
	var ext = extname(base);

	return makeLegalIdentifier(ext.length ? base.slice(0, -ext.length) : base);
}
function commonjs() {
	var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	var filter = createFilter(options.include, options.exclude);
	var bundleUsesGlobal = false;

	var sourceMap = options.sourceMap !== false;

	return {
		resolveId: function resolveId(importee, importer) {
			if (importee[0] !== '.') return; // not our problem

			var resolved = resolve(dirname(importer), importee);
			var candidates = [resolved, resolved + '.js', resolved + (sep + 'index.js')];

			for (var i = 0; i < candidates.length; i += 1) {
				try {
					var stats = statSync(candidates[i]);
					if (stats.isFile()) return candidates[i];
				} catch (err) {/* noop */}
			}
		},

		transform: function transform(code, id) {
			if (!filter(id)) return null;
			if (extname(id) !== '.js') return null;
			if (!firstpass.test(code)) return null;

			var ast = undefined;

			try {
				ast = acorn.parse(code, {
					ecmaVersion: 6,
					sourceType: 'module'
				});
			} catch (err) {
				err.message += ' in ' + id;
				throw err;
			}

			var magicString = new MagicString(code);

			var required = {};
			var uid = 0;

			var scope = attachScopes(ast, 'scope');
			var namedExports = {};
			var usesModuleOrExports = undefined;
			var usesGlobal = undefined;

			walk(ast, {
				enter: function enter(node, parent) {
					if (node.scope) scope = node.scope;

					if (sourceMap) {
						magicString.addSourcemapLocation(node.start);
						magicString.addSourcemapLocation(node.end);
					}

					// Is this an assignment to exports or module.exports?
					if (node.type === 'AssignmentExpression') {
						if (node.left.type !== 'MemberExpression') return;

						var flattened = flatten(node.left);
						if (!flattened) return;

						if (scope.contains(flattened.name)) return;

						var match = exportsPattern.exec(flattened.keypath);
						if (!match || flattened.keypath === 'exports') return;

						if (match[1]) namedExports[match[1]] = true;

						return;
					}

					if (node.type === 'Identifier') {
						if ((node.name === 'module' || node.name === 'exports') && isReference(node, parent) && !scope.contains(node.name)) usesModuleOrExports = true;
						if (node.name === 'global' && isReference(node, parent) && !scope.contains('global')) usesGlobal = true;
						return;
					}

					if (node.type !== 'CallExpression') return;
					if (node.callee.name !== 'require' || scope.contains('require')) return;
					if (node.arguments.length !== 1 || node.arguments[0].type !== 'Literal') return; // TODO handle these weird cases?

					var source = node.arguments[0].value;

					var existing = required[source];
					var name = undefined;

					if (!existing) {
						name = 'require$$' + uid++;
						required[source] = { source: source, name: name };
					} else {
						name = required[source].name;
					}

					magicString.overwrite(node.start, node.end, name);
				},

				leave: function leave(node) {
					if (node.scope) scope = scope.parent;
				}
			});

			var sources = Object.keys(required);

			if (!sources.length && !usesModuleOrExports && !usesGlobal) return null; // not a CommonJS module

			var name = getName(id);

			var importBlock = sources.length ? sources.map(function (source) {
				return 'import ' + required[source].name + ' from \'' + source + '\';';
			}).join('\n') : '';

			var intro = '\n\nvar ' + name + ' = (function (module' + (usesGlobal ? ', global' : '') + ') {\nvar exports = module.exports;\n';
			var outro = '\nreturn module.exports;\n})({exports:{}}' + (usesGlobal ? ', __commonjs_global' : '') + ');\n\nexport default ' + name + ';\n';

			outro += Object.keys(namedExports).map(function (x) {
				return 'export var ' + x + ' = ' + name + '.' + x + ';';
			}).join('\n');

			magicString.trim().prepend(importBlock + intro).trim().append(outro);

			code = magicString.toString();
			var map = sourceMap ? magicString.generateMap() : null;

			if (usesGlobal) bundleUsesGlobal = true;

			return { code: code, map: map };
		},

		intro: function intro() {
			return bundleUsesGlobal ? 'var __commonjs_global = typeof window !== \'undefined\' ? window : typeof global !== \'undefined\' ? global : this;' : '';
		}
	};
}

export default commonjs;